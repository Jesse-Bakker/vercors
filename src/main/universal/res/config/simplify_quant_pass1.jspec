// -*- tab-width:2 ; indent-tabs-mode:nil -*-

class simplify_quant_pass1 {
  _AnyTypeForSimplificationRules g1,g2,g3,g4,g5;
  int e1,e2,e3,e4,e5,e6,e7,e8;
  boolean b1,b2,b3,b4;
  resource r1,r2;
  int i,j;
  rational p1,p2;

  axiom aunitr { e1+0 == e1 }
  axiom aunitl { 0+e1 == e1 }

  axiom munitr { e1*1 == e1 }
  axiom munitl { 1*e1 == e1 }

  axiom I2 {
    0 * e1 == 0
  }
  axiom I3 {
    e1 * 0 == 0
  }

  axiom I1 {
    e1 * e2 + e2 == (e1+1) * e2
  }

  axiom sub_0 { e1 - 0 == e1 }

  // SJ: this can be true if 1 / 0 = 0, violating that e1/e1 == 1 (and acceptably so).
  axiom div_1 { ( 1 / e1 ) * e2 == e2 / e1 }
  axiom div_2 { e2 * ( 1 / e1 ) == e2 / e1 }

  // SJ: div_3 is not true for e1 == 0
  // axiom div_3 { e1 / e1 == 1 }
  axiom div_4 { e1 / 1 == e1 }

  axiom B1 {
    true && b1 == b1
  }
  axiom B1or {
    true || b1 == true
  }

  axiom B2or {
    false || b1 == b1
  }
  axiom B2 {
    false && b1 == false
  }

  // SJ: added these because I ran into this at some point:
  // in forall clauses a 0 <= i && i < n gets turned into something with a \meberof clause
  axiom GE {
    e1 >= e2 == e2 <= e1
  }
  axiom GE_strict {
    e1 > e2 == e2 < e1
  }

  axiom A2 {
    e1 <= e2 && e2 < e3 == (e2 \memberof {e1..e3})
  }
  axiom A2_comm { // SJ: again, this is sometimes written in the 'wrong' order, so I added the other version
    e2 < e3 && e1 <= e2 == (e2 \memberof {e1..e3})
  }

  axiom starall_bool {
    (\forall* int l; b1; b2)
      ==
    (\forall int l; b1; b2)
  }

  axiom quant_cond_main_equal {
    (\forall int l; b1; b1) == true
  }

  axiom split_forall {
    (\forall int l; b1; b2 && b3)
     ==
    (\forall int l; b1; b2) && (\forall int l; b1; b3)
  }

  axiom A3 {
    (\forall int l; b1 ; (\forall int m; (b2!l) && b3 ; b4 ) )
      ==
    (\forall int l; b1 && b2 ; (\forall int m; b3 ; b4 ) )
  }
  axiom A3r {
    (\forall* int l; b1 ; (\forall* int m; (b2!m) && b3 ; r1 ) )
      ==
    (\forall* int l; b1 && b2 ; (\forall* int m; b3 ; r1 ) )
  }

  axiom single_r { (\forall* int l; b1 ; (l == (e1!l)) ==> r1 )
               ==
                 (\let int l=e1 ; b1 ==> r1 ) }

  axiom A4 {
    (\forall* int l; b1 ; b2 ==> r1 )
      ==
    (\forall* int l; b1 && b2 ; r1 )
  }

  axiom A4b {
    (\forall int l; b1 ; b2 ==> b4 )
      ==
    (\forall int l; b1 && b2 ; b4 )
  }

  axiom A5 {
    (i \memberof {e1 .. e2}) && i > e3
      ==
    (i \memberof {e1<=e3?e3+1:e1 .. e2})
  }

  axiom A6 {
    (i \memberof {e1 .. e2}) && i < e3
      ==
    (i \memberof {e1 .. e3<e2?e3:e2})
  }

  // SJ: repaired by adding the exist here.
  axiom A7 {
    (\forall* int l; b1 ; Value((e1!l)) )
      ==
    (\exists int l; true ; b1 ) ==> Value(e1)
  }

  axiom A1 {
    (\forall int l; (l \memberof { e1 .. e2 }) ; (b1!l))
      ==
    e1 < e2 ==> b1
  }

  axiom A1_chain {
    (\forall int l; (l \memberof {e1 .. e2}) && (b2!l) ; (b1!l))
      ==
    (e1 < e2 && b2) ==> b1
  }

/*
// SJ: the more generic version of the above, as shown below, can make it harder to solve things
  axiom A1 {
    (\forall int l; b1 ; (b2!l))
    ==
    ((\exists int l; true ; b1 ) ==> b2)
  }
*/

  int ar[];


//  axiom deindex2 {
//    (\forall* int l; e1 ; Perm(ar[ this.multidim_index_2(e2,e3,e4,e5) ], e6 ))
//    ==
//    (\forall* int l; e1 ; Perm(ar[ e4*e3 + e5 ], e6 ))
//  }

  axiom perm_any {
    Perm(ar[*],e1) == (\forall* int i_fresh ; 0 <= i_fresh && i_fresh < ar.length ; Perm(ar[i_fresh],e1))
  }

  axiom array_perm {
    ArrayPerm(ar,e1,e2,e3,e4)
     ==
    (\forall* int i_fresh ; 0 <= i_fresh && i_fresh < e3 ; Perm(ar[e2 * i_fresh + e1],e4))
  }

  axiom single_b { (\forall int l; b1 ; (l == (e1!l)) ==> b2 )
               ==
                 (\let int l=e1 ; b1 ==> b2 ) }
  /* // SJ: these are already matched by axiom A2
   axiom inlist { (\forall* int l; e1 <= l && l < e2 ; r1 )
                 ==
                 (\forall* int l;  ( l \memberof { e1 .. e2 }) ; r1 ) }

   axiom inlistb { (\forall int l; e1 <= l && l < e2 ; b1 )
                 ==
                 (\forall int l;  ( l \memberof { e1 .. e2 }) ; b1 ) }
*/
   axiom LEFTPLUS { (\forall* int l;( l \memberof { e1 .. e2 }) ; Perm( ar [ (e3!l)+l ] , (p1!l) ) )
                 ==
                 (\forall* int l;  ( l \memberof { e3+e1 .. e3+e2 }) ; Perm( ar [ l ] , p1 ) ) }

   axiom LEFTPLUS2 { (\forall* int l;( l \memberof { e1 .. e2 }) ;
                        (\forall* int m ; (m \memberof {(e5!l)..(e6!l)}) ;
                        Perm( ar [ (e3!l)+l ] , e4 ) ))
                 ==
                   (\forall* int m ; (m \memberof {e5..e6}) ;
                 (\forall* int l;  ( l \memberof { e3+e1 .. e3+e2 }) ; Perm( ar [ l ] , e4 ) ))
                  }

   axiom constant { (\forall* int l;( l \memberof { e1 .. e2 }) ; Perm( (e3!l) , (e4!l) ) )
                 ==
                   e1 < e2 ==> Perm(e3,e4*(e2-e1)) }

   axiom constant_2 {
      (\forall* int l; (l \memberof {e1 .. e2});
          (\forall* int m; (m \memberof {(e3!l) .. (e4!l)}); Perm((e5!l), (p1!l))))
      ==
      (e1 < e2) ==> (\forall* int m; (m \memberof {e3 .. e4}); Perm(e5, (e2 - e1) * p1))
   }

   axiom right_plus { (\forall* int l;( l \memberof { e1 .. e2 }) ; Perm( ar [ l+(e3!l) ] , (p1!l) ) )
                 ==
                 (\forall* int l;  ( l \memberof { e1+e3 .. e2+e3 }) ; Perm( ar [ l ] , p1 ) ) }

   axiom minus { (\forall* int l;( l \memberof { e1 .. e2 }) ; Perm( ar [ l-(e3!l) ] , (e4!l) ) )
                 ==
                 (\forall* int l;  ( l \memberof { e1-e3 .. e2-e3 }) ; Perm( ar [ l ] , e4 ) ) }

   axiom left_plusb { (\forall int l;( l \memberof { e1 .. e2 }) ; ar [ (e3!l) + l ] == (e4!l) )
                 ==
                 (\forall int l;  ( l \memberof { e3+e1 .. e3+e2 }) ; ar [ l ] == e4 ) }


  /* // SJ: Tried to fix this, but still unsure if this holds... Removing it didn't destroy any tests so I'll keep it commented
   axiom nested_bool_1_a_00 {
        (\forall int l;( l \memberof { 0 .. e1 }) ;
           (\forall int m;( m \memberof { 0 .. (e2!l) }) ;
              ar[ l * ((e3!l)!m) + m ] == \old(ar[ l * e3 + m ]) ))
    ==
       (0 <= e1 && 0 <= e2) ==>
       (\forall int k_fresh;(k_fresh \memberof { 0 .. e1*e3}) && (k_fresh % e3 < e2);
          ar[k_fresh] == \old(ar[k_fresh]) )
   }
   */


// SJ: I repaired this from something that was clearly false. Unsure if it helps.
   axiom nested_bool_1 {
        (\forall int l;( l \memberof { 0 .. e1 }) ;
           (\forall int m;( m \memberof { 0 .. (e2!l) }) ;
              ar[ e3 + m ] == ((e4!l)!m) ))
    ==
       e1 > 0 && e2 > 0 ==>
       (\forall int k_fresh;(k_fresh \memberof {0 .. e1*e2});
          (\let int l=k_fresh/e2 ; (\let int m=k_fresh%e2 ;
             ar[ e3 + m ] == e4 )))
   }

// SJ: same as above, but with i and j flipped
   axiom nested_bool_2 {
        (\forall int m;( m \memberof { 0 .. e2 }) ;
          (\forall int l;( l \memberof { 0 .. (e1!m) }) ;
              ar[ e3 + m ] == e4 ))
    ==
       e1 > 0 && e2 > 0 ==>
       (\forall int k_fresh;(k_fresh \memberof { 0 .. e1*e2});
          (\let int l=k_fresh/e2 ; (\let int m=k_fresh%e2 ;
//            ( l \memberof [ 0 .. e1 )) && ( m \memberof { 0 .. e2 }) && ar[ e3 + m ] == e4 )))
            ar[ e3 + m ] == e4 )))
   }

   /*
   // SJ: Does not hold if e1 <= 0 or if e2 > e3, did not try to fix: rule didn't seem all that needed
   axiom nested_bool_1_a_0 {
        (\forall int l;( l \memberof { 0 .. e1 }) ;
           (\forall int m;( m \memberof { 0 .. e2 }) ;
              (ar[ l * ((e3!l)!m) + m ] \memberof ((e4!l)!m)) ))
    ==
       e2 <= e3 &&
       (\forall int k_fresh;(k_fresh \memberof { 0 .. e1*e3}) && (k_fresh % e3 < e2);
          (ar[k_fresh] \memberof e4))
   }

//   axiom nested_bool_1_a {
//        (\forall int l;( l \memberof {0 .. e1 }) ;
//           (\forall int m;( m \memberof {0 .. e2}) ;
//              (ar[ e3 + m ] \memberof e4) ))
//    ==
//       (\forall int k_fresh;(k_fresh \memberof {0 .. e1*e2});
//          (\let int l=k_fresh/e2 ; (\let int m=k_fresh%e2 ;
//             (ar[ e3 + m ] \memberof e4) )))
//   }

   axiom nested_bool_2_a {
        (\forall int m;( m \memberof {0 .. e2}) ;
          (\forall int l;( l \memberof {0 .. e1}) ;
              (ar[ e3 + m ] \memberof e4) ))
    ==
       (\forall int k_fresh;(k_fresh \memberof {0 .. e1*e2});
          (\let int l=k_fresh/e2 ; (\let int m=k_fresh%e2 ;
            (ar[ e3 + m ] \memberof e4) )))
   } */

   // SJ: given that e1 / 0 = 0, this implies that e1 % 0 = e1, violating e1 % d < d (and acceptably so..)
   axiom div_mod {
     (e1 / e2) * e2 + (e1 % e2) == e1
   }


   axiom reorder_1 {
     ( j \memberof {e3 * i .. e3 * (i + 1)})
       ==
     ( j \memberof {i * e3 .. (i + 1) * e3})
   }

   /*
   // SJ: fixed this slightly, trying to see if removing this breaks anything..
   axiom triple_1 {
     (\forall* int l;( l \memberof {0 .. e1} );
       (\forall* int m;( m \memberof {0 .. (e2!l)} );
         (\forall* int k;( k \memberof {((e3!l)!m) .. ((e4!l)!m)} );
           Perm(ar[k * ( e1 * e2 ) + ( m * e1 + l) ],e5) )))
      ==
     e1 > 0 && e2 > 0 && e3 < e4 ==> (\forall* int l;( l \memberof {e1 * e2 * e3 .. e1 * e2 * e4});Perm(ar[l],e5))
   }
   */

   // SJ: I added the requirement that e3 should not depend on i.
   // This rule is probably useful for paralel blocks
   axiom nested_1 {
        (\forall* int l;( l \memberof ({ e1 .. e2 }) );
            (\forall* int m;( m \memberof {l * (e3!l) .. (l + 1) * e3} );
                (r1!l) ))
        ==
        e3 > 0 ==> (\forall* int m;( m \memberof {e1 * e3 .. e2 * e3} ); r1 )
        }

   /* // SJ: I guess these are allready taken care of by the rule nested_1, plus they are wrong..
   axiom nested_Z1 {
        (\forall* int l;( l \memberof {e1 .. e2} );
            (\forall* int m;( m \memberof {0 .. e3} );
                Perm( ar[e5 + (l*e3+m) ] , ((e4!l)!m) ) ))
        ==
        (\forall* int m;( m \memberof {e1 * e3 .. e2 * e3} ); Perm(ar[e5+m],e4) )
        }

   axiom nested_Z1_x {
        (\forall* int l;( l \memberof {e1 .. e2} ) && e6;
            (\forall* int m;( m \memberof {0 .. e3} );
                Perm( ar[e5 + (l*e3+m) ] , ((e4!l)!m) ) ))
        ==
        (\forall* int m;( m \memberof {e1 * e3 .. e2 * e3} ) && e6; Perm(ar[e5+m],e4) )
        }
   */

   /* // SJ: the following only works if e4 <= e3, the other case is missing
   axiom nested_x1 {
        (\forall* int l;( l \memberof {e1 .. e2} );
            (\forall* int m;( m \memberof {l * (e3!l) .. l * e3 + (e4!l)} );
                (r1!l) ))
        ==
          (e4 <= e3) ==>
        (\forall* int m;( m \memberof {e1 * e3 .. e2 * e3} ) && (m % e3 < e4); r1 )
        } */

   // SJ: same as in nested_1: I don't see where this would be useful, but it's nice to have the symmetry
   axiom nested_1b {
        (\forall int l;( l \memberof { e1 .. e2 } );
            (\forall int m;( m \memberof {l * (e3!l) .. (l + 1) * e3} );
                (b1!l) ))
        ==
        e3 > 0 ==> (\forall int m;( m \memberof {e1 * e3 .. e2 * e3} ); b1 )
        }

   /* // SJ: same comment as for nested_x1, so also commented
   axiom nested_x1b {
        (\forall int l;( l \memberof { e1 .. e2 } );
            (\forall int m;( m \memberof {l * e3 .. l * e3 + e4} );
                (b1!l) ))
        ==
          (e4 <= e3) **
        (\forall int m;( m \memberof {e1 * e3 .. e2 * e3} ) && (m % e3 < e4); b1 )
        }
   */

   /* // SJ: not repaired yet, fortunately, this is not really needed either
   axiom nested_2 {
        (\forall* int l;( l \memberof { e1 .. e2 } );
            (\forall* int m;( m \memberof {((e4!l) + l) * e3 .. (e4 + l + 1) * e3} );
                (r1!l) ))
        ==
        (\forall* int m;( m \memberof {(e4 + e1) * e3 .. (e4 + e2) * e3} ); r1 )
        }

   axiom nested_2x {
        (\forall* int l;( l \memberof { e1 .. e2 } );
          (\forall* int k ; (b1!l) ;
            (\forall* int m;( m \memberof {((e4!l) + l) * e3 .. (e4 + l + 1) * e3} );
                (r1!l) )))
        ==
          (\forall* int k ; b1 ;
        (\forall* int m;( m \memberof {(e4 + e1) * e3 .. (e4 + e2) * e3} ); r1 ))
        }
    */

    axiom lin1 {
        (\forall* int l;( l \memberof {e1 * (e2!l) * (e3!l) .. e4}) ; r1 )
           ==
        (\forall* int l;( l \memberof {e1 * (e2*e3) .. e4}) ; r1 )
    }

    axiom lin2 {
        (\forall* int l;( l \memberof {e4 .. e1 * (e2!l) * (e3!l)}) ; r1 )
           ==
        (\forall* int l;( l \memberof {e4 .. e1 * (e2*e3)}) ; r1 )
    }

    axiom split1 {
       (\forall* int l;b1;r1**r2)
         ==
       (\forall* int l;b1;r1) ** (\forall* int l;b1;r2)
    }

    axiom split2 {
       (\forall* int l;b1;PointsTo(e2,e3,e4))
         ==
       (\forall* int l;b1;Perm(e2,e3)) ** (\forall int l;b1;e2==e4)
    }

    /* // SJ: unfortunately, this introduces an existential quantifier which is not always a good thing...
    axiom nested_value {
      (\forall* int l ; e1 ; (\forall* int m ; (e2!l) ; Value((e3!l))))
        ==
      (\exists int l; true ; e1 ) ==> (\forall* int m ; e2 ; Value(e3))
    }
    */

  axiom resource_independent_quant {
    (\forall* int tid; (tid \memberof {e1..e2}); (Perm(g1, p1)!tid))
    ==
    (e1<e2) ==> Perm(g1, p1*(e2-e1))
  }

  axiom simplify_distribute_perm_par {
    (\forall* int tid;(tid \memberof {e1 .. e2}); ((\forall* int l; (l \memberof {e3 .. e4}); Perm(e5, p1\p2))!tid))
    ==
    (e1 < e2) ==> (\forall* int l; (l \memberof {e3 .. e4}); Perm(e5, (p1 * (e2 - e1))\p2))
  }
}
